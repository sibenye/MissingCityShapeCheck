import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.nio.file.StandardOpenOption;
import java.security.KeyManagementException;
import java.security.KeyStoreException;
import java.security.NoSuchAlgorithmException;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import javax.net.ssl.HostnameVerifier;
import javax.net.ssl.SSLSession;

import org.apache.http.client.ClientProtocolException;
import org.apache.http.client.methods.CloseableHttpResponse;
import org.apache.http.client.methods.HttpGet;
import org.apache.http.conn.ssl.SSLConnectionSocketFactory;
import org.apache.http.conn.ssl.TrustSelfSignedStrategy;
import org.apache.http.impl.client.CloseableHttpClient;
import org.apache.http.impl.client.HttpClients;
import org.apache.http.ssl.SSLContextBuilder;

/*
 * This Java source file was generated by the Gradle 'init' task.
 */
public class Library {

    private static String geoEntitiesUrl = "https://search-api.helium.forrent.com/geography/entities";
    private static String geoShapesUrl = "https://search-api.helium.forrent.com/geography/shapes/findOne";

    private static String compareBothEntitesAndShapesFile = System.getProperty("user.dir") + "/output/side_by_side_comapre.csv";
    private static String missingCitiesOnlyFile = System.getProperty("user.dir") + "/output/missingCitiesOnly.csv";

    public static void main(final String[] args) throws IOException, NoSuchAlgorithmException, KeyStoreException, KeyManagementException {
        //Files.deleteIfExists(Paths.get(compareBothEntitesAndShapesFile));
        //Files.deleteIfExists(Paths.get(missingCitiesOnlyFile));

       // Files.createFile(Paths.get(compareBothEntitesAndShapesFile));
        //Files.createFile(Paths.get(missingCitiesOnlyFile));

        System.out.println(compareBothEntitesAndShapesFile);
        System.out.println(missingCitiesOnlyFile);

        final String header1 = "CompoundCityId,cityId,stateId,Entity,Shape\n";
        final String header2 = "CompoundCityId,cityId,stateId\n";

        Files.write(Paths.get(compareBothEntitesAndShapesFile), header1.getBytes());
        Files.write(Paths.get(missingCitiesOnlyFile), header2.getBytes());

        final SSLContextBuilder builder = new SSLContextBuilder();
        builder.loadTrustMaterial(null, new TrustSelfSignedStrategy());
        final SSLConnectionSocketFactory sslsf = new SSLConnectionSocketFactory(
                builder.build(), new HostnameVerifier()
                {

                    @Override
                    public boolean verify(final String hostname, final SSLSession session)
                    {
                        // TODO Auto-generated method stub
                        return true;
                    }
                });

        final CloseableHttpClient httpClient = HttpClients.custom().setSSLSocketFactory(
                sslsf).build();


        final List<String> geoEntityOutputLines = new ArrayList<>();
        final List<String> geoShapeOutputLines = new ArrayList<>();
        try {
            final BufferedReader br = new BufferedReader(new FileReader("cityId_list.txt"));
            int count = 0;
            int batchCnt = 0;

            String line = br.readLine();
            while (line != null)
            {
                count++;
                final String[] lineSplit = line.split("-");
                final String cityId = lineSplit[0];
                final String stateId = lineSplit[1];

                final Map<String, String> output = processLine(line, httpClient);
                //System.out.println(output.get("geoEntityOutput"));
                //System.out.println(output.get("geoShapeOutput"));
                final String geoEntityOutput = output.get("geoEntityOutput");
                final String geoShapeOutput = output.get("geoShapeOutput");

                final String geoEntityOutputLine = buildGeoEntityOutputLine(line, cityId, stateId, geoEntityOutput, geoShapeOutput);

                geoEntityOutputLines.add(geoEntityOutputLine);

                if (geoShapeOutput.equals("NOT_FOUND")
                        && geoEntityOutput.equals("FOUND")) {
                    final String geoShapaeOutputLine = buildGeoShapeOutputLine(line, cityId, stateId);
                    geoShapeOutputLines.add(geoShapaeOutputLine);
                }

                if (count == 10000) {
                    batchCnt++;
                    System.out.println("Writing batch " + batchCnt);
                    writeToFile(geoEntityOutputLines, geoShapeOutputLines);
                    count = 0;
                    geoEntityOutputLines.clear();
                    geoShapeOutputLines.clear();
                }

               line = br.readLine();
            }

            if (geoEntityOutputLines.size() > 0 || geoShapeOutputLines.size() > 0) {
                System.out.println("Writing last batch");
                writeToFile(geoEntityOutputLines, geoShapeOutputLines);
            }


        } catch (final Exception e) {
            // TODO Auto-generated catch block
            e.printStackTrace();
        }
    }
    public static Map<String, String> processLine(final String compundCityId, final CloseableHttpClient httpClient) throws ClientProtocolException, IOException {
        final Map<String, String> output = new HashMap<>();


        final String geoEntitiesRequestUrl = geoEntitiesUrl + "?id=city." + compundCityId
                + "&context=FRC&locale=EN";
        final String geoShapeRequestUrl = geoShapesUrl + "?geoType=CITY&key=" + compundCityId + "&shapeType=BOUNDARY&includeGeometry=false";

        final CloseableHttpResponse geoEntityResponse = httpClient.execute(new HttpGet(geoEntitiesRequestUrl));
        final CloseableHttpResponse geoShapeResponse = httpClient.execute(new HttpGet(geoShapeRequestUrl));

        try {
            final int geoEntityStatusCode = geoEntityResponse.getStatusLine().getStatusCode();
            final int geoShapeStatusCode = geoShapeResponse.getStatusLine().getStatusCode();

            output.put("geoEntityOutput", getStatusCodeText(geoEntityStatusCode));
            output.put("geoShapeOutput", getStatusCodeText(geoShapeStatusCode));
        } finally {
            geoEntityResponse.close();
            geoShapeResponse.close();
        }

        return output;
    }

    private static String getStatusCodeText(final int statusCode)
    {
        if (statusCode == 200) {
            return "FOUND";
        } else if (statusCode == 404) {
            return "NOT_FOUND";
        } else {
            return "UNKNOWN";
        }

    }

    private static String buildGeoEntityOutputLine(final String compoundCityId, final String cityId,
            final String stateId, final String geoEntityOutput, final String geoShapeOutput)
    {
        return String.join(",", compoundCityId, cityId, stateId, geoEntityOutput, geoShapeOutput);
    }

    private static String buildGeoShapeOutputLine(final String compoundCityId, final String cityId, final String stateId)
    {
        return String.join(",", compoundCityId, cityId, stateId);
    }

    private static void writeToFile(final List<String> geoEntityOutputLines, final List<String> geoShapeOutputLines)
            throws IOException
    {
        Files.write(Paths.get(compareBothEntitesAndShapesFile), geoEntityOutputLines, StandardCharsets.UTF_8,
                StandardOpenOption.WRITE, StandardOpenOption.APPEND);
        Files.write(Paths.get(missingCitiesOnlyFile), geoShapeOutputLines, StandardCharsets.UTF_8,
                StandardOpenOption.WRITE, StandardOpenOption.APPEND);
    }
}
